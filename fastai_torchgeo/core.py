# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['load_tif', 'open_tif', 'GeoTensorImage']

# %% ../nbs/00_core.ipynb 4
import rasterio as rio
import numpy as np
import pathlib
import torch as th
import fastai.vision.all as fv
import fastcore.all as fc
import torch.nn as nn
from pathlib import Path
import matplotlib.pyplot as plt
import matplotlib as mpl
from typing import Union
from functools import partial

# %% ../nbs/00_core.ipynb 5
def load_tif(
    fpath: str | pathlib.Path,  # filename
    chnls_last=True,  # transpose from c,h,w to h,w,c (assume c,h,w on rio.read input)
) -> (
    np.ndarray
):  # ndarray will return either h,w,c or c,h,w depending on chnls_last is True or False
    """
    Loads a geotiff file, transpose its channels if necessary, and return the image data as a numpy array.

    #### Parameters

    - `fpath` (str|pathlib.Path): The file path of the image to be loaded.
    - `chnls_last` (bool, optional): If set to `True`, the function will return the image data in the format (height, width, channels) (h, w, c). If set to `False`, the function will return the image data in the format (channels, height, width) (c, h, w). Default value is `True`.

    #### Returns

    - `numpy.ndarray`: The image data as a NumPy array. The shape of the array depends on the value of `chnls_last`.
      - If `chnls_last` is `True`, the returned array will have the shape `(height, width, channels)`.
      - If `chnls_last` is `False`, the returned array will have the shape `(channels, height, width)`.
    """
    with rio.open(fpath) as src:
        data = src.read()
    if chnls_last:
        return data.transpose([1, 2, 0])  # return as h,w,c
    return data

# %% ../nbs/00_core.ipynb 14
def open_tif(
    fn: str | pathlib.Path,  # The path to the TIFF image file
    chnls: [int] = None,  # The channels to load from the image
    chnls_last: bool = True,  # If True, the channel dimension is the last dimension
    cls=th.Tensor,  # The class of the tensor to create
) -> th.Tensor:  # A tensor array of the image
    """
    Creates a tensor from a TIFF image file.

    #### Parameters

    - `fn` (str): The path to the TIFF image file.
    - `chnls` (list of int, optional): The channels to load from the image. Default to `None`, which loads all channels
    - `chnls_last` (bool, optional): If `True`, the channel dimension is the last dimension. Default to `True`.
    - `cls` (class, optional): The class of the tensor to create. Defaults to `torch.Tensor`

    #### Returns

    - `Tensor`: A pytorch tensor created from the TIFF image file.
    """

    arr = load_tif(fn, chnls_last=chnls_last)
    if chnls is not None:
        arr = arr[..., chnls] if chnls_last else arr[..., chnls, :, :]
    th_arr = th.from_numpy(arr.astype(np.int32)).type(th.float32)
    return cls(th_arr)

# %% ../nbs/00_core.ipynb 18
class GeoTensorImage(fv.TensorImage):
    """
    A TensorImage for geotiffs

    Can contain more than 3 channels (e.g. 12 band sentinel-2 images) as well as a
    bigger range of values (16-bit vs 8-bit) than your typical image formats

    #### Attributes

    - `chnls_first` (bool): If True, the format of the tensor is c,h,w else its h,w,c
                            where c = channels, h = height, w = width

    #### Methods

    - `create(data, chnls, chnls_first)`: (classmethod) create a `GeoTensorImage` from a file or numpy array
    - `show(chnls,scaler,bright, ctx)`: display a GeoTensorImage
    """

    def __init__(self, x, chnls_first=False):
        self.chnls_first = chnls_first

    def __repr__(self):
        return f"GeoTensorImage: {self.shape}"

    @classmethod
    def create(
        cls,  # GeoTensorImage Class or GeoTensorImage subclass to instantiate
        data: Union[
            Path, str, np.ndarray
        ],  # The image data that the class method is called on.
        chnls: [
            int
        ] = None,  # An optional list of channels to filter. Defaults to None, which does no filtering
        chnls_first: bool = True,  # A boolean flag indicating whether the channels are returned c,h,w or h,w,c. Defaults to True - c,h,w
    ) -> (
        fv.TensorImage
    ):  # An instance of the TensorImage class with appropriate image formatting.
        """
        (class method) Returns an instance of the class with the input image data formatted appropriately.

        If input is Path/str and ends with "tif", opens it using open_tif function.
        If input is np.ndarray, transposes it if chnls_first.
        Otherwise, input is used as is.

        ## Parameters:

        - `data` (Union[Path, str, np.ndarray]): The image data that the class method is called on.
        - `chnls` ([int]): An optional list of channels to filter. Defaults to None, which does no filtering.
        - `chnls_first` (bool, optional): A boolean flag indicating whether the channels are in the first or last
                                          dimension of the input array. Defaults to True.

        ## Returns

        - GeoTensorImage: An instance of the GeoTensorImage class with appropriate image formatting.

        """

        if isinstance(data, Path) or isinstance(data, str):
            if str(data).endswith("tif"):
                im = open_tif(
                    fn=data, chnls=chnls, chnls_last=not chnls_first, cls=th.Tensor
                )
        elif isinstance(data, np.ndarray):
            if chnls_first:
                # assume chnls last coming in
                data = data.transpose([2, 0, 1])  # data out  as c,h,w
            im = th.from_numpy(data)
        else:
            im = data

        return cls(im, chnls_first=chnls_first)

    def show(
        self,
        chnls: [int] = [3, 2, 1],  # list of chnls to include
        scaler: float = 1.0,  #
        bright: float = 1.0,
        ctx: mpl.axes.Axes = None,
    ) -> mpl.image.AxesImage:
        """
        Shows the GeoTensorImage object in a matplotlib figure.

        Args:
            chnls: A list of channel indices to show. The default is [3, 2, 1].
            scaler: A float value to scale the image by. The default is 1.0.
            bright: A float value to brighten the image by. The default is 1.0.
            ctx: A matplotlib context object. The default is None.

        Returns:
            The matplotlib Axes image.
        """
        if self.ndim > 2:
            visu_img = (
                self[..., chnls]
                if not self.chnls_first
                else self.permute([1, 2, 0])[..., chnls]
            )
        else:
            visu_img = self

        visu_img = visu_img.squeeze()
        if scaler is None:
            visu_img /= visu_img.max()
        else:
            visu_img /= visu_img.max() * scaler

        visu_img *= bright
        visu_img = np.where(visu_img > 1, 1, visu_img)
        visu_img = np.where(visu_img < 0, 0, visu_img)

        ax = plt.imshow(visu_img) if ctx is None else ctx.imshow(visu_img)

        return ax
